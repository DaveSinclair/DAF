/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "daf_protocol.h"

bool_t
xdr_Iu64 (XDR *xdrs, Iu64 *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_Iu32 (XDR *xdrs, Iu32 *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_Iu16 (XDR *xdrs, Iu16 *objp)
{
	register int32_t *buf;

	 if (!xdr_u_short (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_Iu8 (XDR *xdrs, Iu8 *objp)
{
	register int32_t *buf;

	 if (!xdr_u_char (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_pathnamestring (XDR *xdrs, pathnamestring *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, MAX_PATHNAME_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_hostnamestring (XDR *xdrs, hostnamestring *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, MAX_HOSTNAME_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_error_types (XDR *xdrs, remote_client_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_tag_error_types (XDR *xdrs, remote_client_clear_tag_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_ident_error_types (XDR *xdrs, remote_client_clear_ident_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_alltags_error_types (XDR *xdrs, remote_client_query_alltags_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cancel_tag_error_types (XDR *xdrs, remote_client_cancel_tag_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cancel_ident_error_types (XDR *xdrs, remote_client_cancel_ident_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_copyfile_error_types (XDR *xdrs, remote_client_copyfile_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_deletefile_error_types (XDR *xdrs, remote_client_deletefile_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cmd_error_types (XDR *xdrs, remote_client_cmd_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_dirlist_error_types (XDR *xdrs, remote_client_dirlist_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_start_scenario_error_types (XDR *xdrs, remote_client_start_scenario_error_types *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_filehandle (XDR *xdrs, filehandle *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_int (xdrs, &objp->len))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->bytes, MAX_FILEHANDLE_LEN,
		sizeof (u_char), (xdrproc_t) xdr_u_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_cmd_log_state (XDR *xdrs, cmd_log_state *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_cmd_log_entry (XDR *xdrs, cmd_log_entry *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_u_int (xdrs, &objp->tag))
			 return FALSE;
		 if (!xdr_u_int (xdrs, &objp->pid))
			 return FALSE;
		 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->state))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->status))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->start_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->end_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->timeout_at_time))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->state);
		IXDR_PUT_LONG(buf, objp->status);
		IXDR_PUT_U_LONG(buf, objp->start_time);
		IXDR_PUT_U_LONG(buf, objp->end_time);
		IXDR_PUT_U_LONG(buf, objp->timeout_at_time);
		IXDR_PUT_BOOL(buf, objp->fail_on_timeout);
		}
		 if (!xdr_vector (xdrs, (char *)objp->cmdstring, MAX_CMD_LEN,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->identstring, MAX_IDENT_LEN,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->agent_log_pathname, MAX_PATHNAME_LEN,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (cmd_log_entry), (xdrproc_t) xdr_cmd_log_entry))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_u_int (xdrs, &objp->tag))
			 return FALSE;
		 if (!xdr_u_int (xdrs, &objp->pid))
			 return FALSE;
		 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->state))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->status))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->start_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->end_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->timeout_at_time))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
				 return FALSE;

		} else {
		objp->state = IXDR_GET_U_LONG(buf);
		objp->status = IXDR_GET_LONG(buf);
		objp->start_time = IXDR_GET_U_LONG(buf);
		objp->end_time = IXDR_GET_U_LONG(buf);
		objp->timeout_at_time = IXDR_GET_U_LONG(buf);
		objp->fail_on_timeout = IXDR_GET_BOOL(buf);
		}
		 if (!xdr_vector (xdrs, (char *)objp->cmdstring, MAX_CMD_LEN,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->identstring, MAX_IDENT_LEN,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->agent_log_pathname, MAX_PATHNAME_LEN,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (cmd_log_entry), (xdrproc_t) xdr_cmd_log_entry))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->pid))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->state))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->start_time))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->end_time))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->timeout_at_time))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->cmdstring, MAX_CMD_LEN,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->identstring, MAX_IDENT_LEN,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->agent_log_pathname, MAX_PATHNAME_LEN,
		sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (cmd_log_entry), (xdrproc_t) xdr_cmd_log_entry))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_cmd_log (XDR *xdrs, cmd_log *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->first, sizeof (cmd_log_entry), (xdrproc_t) xdr_cmd_log_entry))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->last, sizeof (cmd_log_entry), (xdrproc_t) xdr_cmd_log_entry))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cntrl_args (XDR *xdrs, remote_client_cntrl_args *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->clear_shared_memory_flag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cntrl_res (XDR *xdrs, remote_client_cntrl_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_run_cmd_args (XDR *xdrs, remote_client_run_cmd_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_run_cmd_outcome (XDR *xdrs, remote_client_run_cmd_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->valid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->outputline, MAX_CMD_OUTPUT_LINE_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_run_cmd_res (XDR *xdrs, remote_client_run_cmd_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_run_cmd_outcome (xdrs, &objp->remote_client_run_cmd_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_stringlist (XDR *xdrs, stringlist *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->item, ~0))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->next, sizeof (stringlist), (xdrproc_t) xdr_stringlist))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_prepare_cmd_args (XDR *xdrs, remote_client_prepare_cmd_args *objp)
{
	register int32_t *buf;

	 if (!xdr_Iu32 (xdrs, &objp->timeout))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->actionresultID))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_prepare_cmd_outcome (XDR *xdrs, remote_client_prepare_cmd_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_prepare_cmd_res (XDR *xdrs, remote_client_prepare_cmd_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_prepare_cmd_outcome (xdrs, &objp->remote_client_prepare_cmd_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_environmentvalue (XDR *xdrs, environmentvalue *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, DAF_ENVIRONMENTVALUE_VALUE_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_envlist (XDR *xdrs, envlist *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct envnode), (xdrproc_t) xdr_envnode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_envnode (XDR *xdrs, envnode *objp)
{
	register int32_t *buf;

	 if (!xdr_environmentvalue (xdrs, &objp->entry))
		 return FALSE;
	 if (!xdr_envlist (xdrs, &objp->next))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_execute_cmd_args (XDR *xdrs, remote_client_execute_cmd_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
		 return FALSE;
	 if (!xdr_envlist (xdrs, &objp->environment_settings))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->run_in_shell))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->actionresultID))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_execute_cmd_outcome (XDR *xdrs, remote_client_execute_cmd_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->valid))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_execute_cmd_res (XDR *xdrs, remote_client_execute_cmd_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_execute_cmd_outcome (xdrs, &objp->remote_client_execute_cmd_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_cmd_args (XDR *xdrs, remote_client_cmd_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
		 return FALSE;
	 if (!xdr_stringlist (xdrs, &objp->environment_settings))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->run_in_background))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->run_in_shell))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->timeout))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->workqueueID_flag))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
		 return FALSE;
	 if (!xdr_Iu32 (xdrs, &objp->actionresultID))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cmd_outcome (XDR *xdrs, remote_client_cmd_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cmd_exit_code))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cmd_exit_signal))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cmd_res (XDR *xdrs, remote_client_cmd_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_cmd_outcome (xdrs, &objp->remote_client_cmd_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_parametername (XDR *xdrs, parametername *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, DAF_PARAMETER_NAME_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_parametervalue (XDR *xdrs, parametervalue *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, DAF_PARAMETER_VALUE_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_parameterlist (XDR *xdrs, parameterlist *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct parameternode), (xdrproc_t) xdr_parameternode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_parameternode (XDR *xdrs, parameternode *objp)
{
	register int32_t *buf;

	 if (!xdr_parametername (xdrs, &objp->name))
		 return FALSE;
	 if (!xdr_parametervalue (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_parameterlist (xdrs, &objp->next))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_start_scenario_args (XDR *xdrs, remote_client_start_scenario_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->project, DAF_PROJECT_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->phase, DAF_PHASE_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->jobname, DAF_SCENARIO_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->loglocation, DAF_LOGDIRECTORY_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->scenariologfile, DAF_LOGFILENAME_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->teststand, DAF_TESTSTAND_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->testlevel, DAF_TESTLEVEL_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->username, DAF_USERNAME_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->comments, DAF_SCENARIORESULT_COMMENTS_LEN))
		 return FALSE;
	 if (!xdr_parameterlist (xdrs, &objp->parameters))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_start_scenario_outcome (XDR *xdrs, remote_client_start_scenario_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_remote_client_start_scenario_error_types (xdrs, &objp->valid_start_scenario))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->errmsg, 256))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_start_scenario_res (XDR *xdrs, remote_client_start_scenario_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_start_scenario_outcome (xdrs, &objp->remote_client_start_scenario_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_query_version_args (XDR *xdrs, remote_client_query_version_args *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->agent_major_version))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->agent_minor_version))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->agent_version_string, 128))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->set_zombie_reaper_debug_flag))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->reset_zombie_reaper_debug_flag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_version_outcome (XDR *xdrs, remote_client_query_version_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->agent_major_version))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->agent_minor_version))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->agent_version_string, 128))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->agent_build_machine, 128))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->p_osdata_is_valid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->p_name, 128))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->p_os_type, 128))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->p_os_version, 128))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->p_os_description, 128))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->p_cpu_architecture, 128))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_version_res (XDR *xdrs, remote_client_query_version_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_query_version_outcome (xdrs, &objp->remote_client_query_version_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_query_tag_args (XDR *xdrs, remote_client_query_tag_args *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_tag_outcome (XDR *xdrs, remote_client_query_tag_outcome *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_bool (xdrs, &objp->valid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->state))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->cmd_exit_code))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->cmd_exit_signal))
				 return FALSE;
		} else {
			IXDR_PUT_BOOL(buf, objp->valid);
			IXDR_PUT_U_LONG(buf, objp->state);
			IXDR_PUT_LONG(buf, objp->cmd_exit_code);
			IXDR_PUT_LONG(buf, objp->cmd_exit_signal);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_bool (xdrs, &objp->valid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->state))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->cmd_exit_code))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->cmd_exit_signal))
				 return FALSE;
		} else {
			objp->valid = IXDR_GET_BOOL(buf);
			objp->state = IXDR_GET_U_LONG(buf);
			objp->cmd_exit_code = IXDR_GET_LONG(buf);
			objp->cmd_exit_signal = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_bool (xdrs, &objp->valid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->state))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cmd_exit_code))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cmd_exit_signal))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_tag_res (XDR *xdrs, remote_client_query_tag_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_query_tag_outcome (xdrs, &objp->remote_client_query_tag_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_query_alltags_args (XDR *xdrs, remote_client_query_alltags_args *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_alltags_outcome (XDR *xdrs, remote_client_query_alltags_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->last))
		 return FALSE;
	 if (!xdr_cmd_log (xdrs, &objp->cmd_log_fragment))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_alltags_res (XDR *xdrs, remote_client_query_alltags_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_query_alltags_outcome (xdrs, &objp->remote_client_query_alltags_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_query_cmdlog_args (XDR *xdrs, remote_client_query_cmdlog_args *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->index))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_cmdlog_outcome (XDR *xdrs, remote_client_query_cmdlog_outcome *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 9 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->tag))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->pid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->state))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->status))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->start_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->end_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->timeout_at_time))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->last))
				 return FALSE;

		} else {
		IXDR_PUT_U_LONG(buf, objp->tag);
		IXDR_PUT_U_LONG(buf, objp->pid);
		IXDR_PUT_U_LONG(buf, objp->state);
		IXDR_PUT_U_LONG(buf, objp->status);
		IXDR_PUT_U_LONG(buf, objp->start_time);
		IXDR_PUT_U_LONG(buf, objp->end_time);
		IXDR_PUT_U_LONG(buf, objp->timeout_at_time);
		IXDR_PUT_BOOL(buf, objp->fail_on_timeout);
		IXDR_PUT_BOOL(buf, objp->last);
		}
		 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
			 return FALSE;
		 if (!xdr_u_int (xdrs, &objp->workqueueID))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 9 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->tag))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->pid))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->state))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->status))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->start_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->end_time))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->timeout_at_time))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->last))
				 return FALSE;

		} else {
		objp->tag = IXDR_GET_U_LONG(buf);
		objp->pid = IXDR_GET_U_LONG(buf);
		objp->state = IXDR_GET_U_LONG(buf);
		objp->status = IXDR_GET_U_LONG(buf);
		objp->start_time = IXDR_GET_U_LONG(buf);
		objp->end_time = IXDR_GET_U_LONG(buf);
		objp->timeout_at_time = IXDR_GET_U_LONG(buf);
		objp->fail_on_timeout = IXDR_GET_BOOL(buf);
		objp->last = IXDR_GET_BOOL(buf);
		}
		 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
			 return FALSE;
		 if (!xdr_u_int (xdrs, &objp->workqueueID))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->pid))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->state))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->status))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->start_time))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->end_time))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->timeout_at_time))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->fail_on_timeout))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->last))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->cmdstring, MAX_CMD_LEN))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->workqueueID))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_cmdlog_res (XDR *xdrs, remote_client_query_cmdlog_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_query_cmdlog_outcome (xdrs, &objp->remote_client_query_cmdlog_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_query_cmds_args (XDR *xdrs, remote_client_query_cmds_args *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_cmds_outcome (XDR *xdrs, remote_client_query_cmds_outcome *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->num_CMD_INITIALISED_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_RUNNING_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_good_status_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_bad_status_commands))
				 return FALSE;
		} else {
			IXDR_PUT_U_LONG(buf, objp->num_CMD_INITIALISED_commands);
			IXDR_PUT_U_LONG(buf, objp->num_CMD_RUNNING_commands);
			IXDR_PUT_U_LONG(buf, objp->num_CMD_COMPLETED_commands);
			IXDR_PUT_U_LONG(buf, objp->num_CMD_COMPLETED_good_status_commands);
			IXDR_PUT_U_LONG(buf, objp->num_CMD_COMPLETED_bad_status_commands);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->num_CMD_INITIALISED_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_RUNNING_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_good_status_commands))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_bad_status_commands))
				 return FALSE;
		} else {
			objp->num_CMD_INITIALISED_commands = IXDR_GET_U_LONG(buf);
			objp->num_CMD_RUNNING_commands = IXDR_GET_U_LONG(buf);
			objp->num_CMD_COMPLETED_commands = IXDR_GET_U_LONG(buf);
			objp->num_CMD_COMPLETED_good_status_commands = IXDR_GET_U_LONG(buf);
			objp->num_CMD_COMPLETED_bad_status_commands = IXDR_GET_U_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_u_int (xdrs, &objp->num_CMD_INITIALISED_commands))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->num_CMD_RUNNING_commands))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_commands))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_good_status_commands))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->num_CMD_COMPLETED_bad_status_commands))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_cmds_res (XDR *xdrs, remote_client_query_cmds_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_query_cmds_outcome (xdrs, &objp->remote_client_query_cmds_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_get_unique_ident_args (XDR *xdrs, remote_client_get_unique_ident_args *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_get_unique_ident_outcome (XDR *xdrs, remote_client_get_unique_ident_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_get_unique_ident_res (XDR *xdrs, remote_client_get_unique_ident_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_get_unique_ident_outcome (xdrs, &objp->remote_client_get_unique_ident_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_query_ident_args (XDR *xdrs, remote_client_query_ident_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_ident_outcome (XDR *xdrs, remote_client_query_ident_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->last))
		 return FALSE;
	 if (!xdr_cmd_log (xdrs, &objp->cmd_log_fragment))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_query_ident_res (XDR *xdrs, remote_client_query_ident_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_query_ident_outcome (xdrs, &objp->remote_client_query_ident_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_clear_tag_args (XDR *xdrs, remote_client_clear_tag_args *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_tag_outcome (XDR *xdrs, remote_client_clear_tag_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_remote_client_clear_tag_error_types (xdrs, &objp->valid_clear))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_tag_res (XDR *xdrs, remote_client_clear_tag_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_clear_tag_outcome (xdrs, &objp->remote_client_clear_tag_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_cancel_tag_args (XDR *xdrs, remote_client_cancel_tag_args *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cancel_tag_outcome (XDR *xdrs, remote_client_cancel_tag_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_remote_client_cancel_tag_error_types (xdrs, &objp->valid_cancel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cancel_tag_res (XDR *xdrs, remote_client_cancel_tag_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_cancel_tag_outcome (xdrs, &objp->remote_client_cancel_tag_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_cancel_ident_args (XDR *xdrs, remote_client_cancel_ident_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cancel_ident_outcome (XDR *xdrs, remote_client_cancel_ident_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_remote_client_cancel_ident_error_types (xdrs, &objp->valid_cancel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_cancel_ident_res (XDR *xdrs, remote_client_cancel_ident_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_cancel_ident_outcome (xdrs, &objp->remote_client_cancel_ident_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_clear_alltags_args (XDR *xdrs, remote_client_clear_alltags_args *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_alltags_outcome (XDR *xdrs, remote_client_clear_alltags_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_remote_client_clear_tag_error_types (xdrs, &objp->valid_clear))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_alltags_res (XDR *xdrs, remote_client_clear_alltags_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_clear_alltags_outcome (xdrs, &objp->remote_client_clear_alltags_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_clear_ident_args (XDR *xdrs, remote_client_clear_ident_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->identstring, MAX_IDENT_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_ident_outcome (XDR *xdrs, remote_client_clear_ident_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_remote_client_clear_ident_error_types (xdrs, &objp->valid_clear))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_clear_ident_res (XDR *xdrs, remote_client_clear_ident_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_clear_ident_outcome (xdrs, &objp->remote_client_clear_ident_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_copyfile_args (XDR *xdrs, remote_client_copyfile_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->remotepathname, MAX_PATHNAME_LEN))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->fromremote))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->requestedlength))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->eof))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_copyfile_outcome (XDR *xdrs, remote_client_copyfile_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->valid_copyfile))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->num_bytes_in_transfer))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->eof))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_copyfile_res (XDR *xdrs, remote_client_copyfile_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_copyfile_outcome (xdrs, &objp->remote_client_copyfile_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_remote_client_deletefile_args (XDR *xdrs, remote_client_deletefile_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->remotepathname, MAX_PATHNAME_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_deletefile_outcome (XDR *xdrs, remote_client_deletefile_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->valid_deletefile))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_deletefile_res (XDR *xdrs, remote_client_deletefile_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_deletefile_outcome (xdrs, &objp->remote_client_deletefile_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_direntrytype (XDR *xdrs, direntrytype *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, MAX_PATHNAME_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dirlist (XDR *xdrs, dirlist *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct dirnode), (xdrproc_t) xdr_dirnode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dirnode (XDR *xdrs, dirnode *objp)
{
	register int32_t *buf;

	 if (!xdr_direntrytype (xdrs, &objp->entry))
		 return FALSE;
	 if (!xdr_dirlist (xdrs, &objp->next))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_dirlist_args (XDR *xdrs, remote_client_dirlist_args *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->remotepathname, MAX_PATHNAME_LEN))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_dirlist_outcome (XDR *xdrs, remote_client_dirlist_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->valid_dirlist))
		 return FALSE;
	 if (!xdr_dirlist (xdrs, &objp->directory))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_dirlist_res (XDR *xdrs, remote_client_dirlist_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_dirlist_outcome (xdrs, &objp->remote_client_dirlist_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_command_state (XDR *xdrs, command_state *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, DAF_STATE_LEN))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_update_workqueue_status_args (XDR *xdrs, remote_client_update_workqueue_status_args *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
			 return FALSE;
		 if (!xdr_bool (xdrs, &objp->update_state))
			 return FALSE;
		 if (!xdr_command_state (xdrs, &objp->state))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_bool (xdrs, &objp->update_tag))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->tag))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->update_pass))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->pass))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->update_end))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->msglevel))
				 return FALSE;
		} else {
			IXDR_PUT_BOOL(buf, objp->update_tag);
			IXDR_PUT_LONG(buf, objp->tag);
			IXDR_PUT_BOOL(buf, objp->update_pass);
			IXDR_PUT_LONG(buf, objp->pass);
			IXDR_PUT_BOOL(buf, objp->update_end);
			IXDR_PUT_LONG(buf, objp->msglevel);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
			 return FALSE;
		 if (!xdr_bool (xdrs, &objp->update_state))
			 return FALSE;
		 if (!xdr_command_state (xdrs, &objp->state))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_bool (xdrs, &objp->update_tag))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->tag))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->update_pass))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->pass))
				 return FALSE;
			 if (!xdr_bool (xdrs, &objp->update_end))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->msglevel))
				 return FALSE;
		} else {
			objp->update_tag = IXDR_GET_BOOL(buf);
			objp->tag = IXDR_GET_LONG(buf);
			objp->update_pass = IXDR_GET_BOOL(buf);
			objp->pass = IXDR_GET_LONG(buf);
			objp->update_end = IXDR_GET_BOOL(buf);
			objp->msglevel = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_Iu32 (xdrs, &objp->workqueueID))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->update_state))
		 return FALSE;
	 if (!xdr_command_state (xdrs, &objp->state))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->update_tag))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->tag))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->update_pass))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->pass))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->update_end))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->msglevel))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_update_workqueue_status_outcome (XDR *xdrs, remote_client_update_workqueue_status_outcome *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, &objp->valid_update))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_remote_client_update_workqueue_status_res (XDR *xdrs, remote_client_update_workqueue_status_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	switch (objp->status) {
	case 0:
		 if (!xdr_remote_client_update_workqueue_status_outcome (xdrs, &objp->remote_client_update_workqueue_status_res_u.outcome))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
